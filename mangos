// 2017.12.08
	

	////////////////////////////////////////////////////////////////
	// mangos 相关的一些记录和阅读 
	
		// Mangos源码分析
			http://www.cppblog.com/ming81/category/15288.html?Show=All

			// (ok) Mangos源码分析（1）：服务器结构探讨之最简单的结构
				http://www.cppblog.com/ming81/archive/2011/01/19/138865.html

			// (ok) (搬运工)Mangos源码分析（2）：服务器结构探讨之登录服的负载均衡
				http://www.cppblog.com/ming81/archive/2011/01/19/138866.html
				对于负载均衡来说，已有了成熟的解决方案。一般最常用，也最简单部署的应该是基于DNS的负载均衡系统了，
				其通过在DNS中为一个域名配置多个IP地址来实现。最新的DNS服务已实现了根据服务器系统状态来实现的动态负载均衡，
				也就是实现了真正意义上的负载均衡，这样也就有效地解决了当某台登录服当机后，DNS服务器不能立即做出反应的问题。
				当然，如果找不到这样的解决方案，自己从头打造一个也并不难。而且，通过DNS来实现的负载均衡已经包含了所做的修改对登录服及客户端的透明。

			// (ok) (搬运工)Mangos源码分析（3）：服务器结构探讨之简单的世界服实现
				http://www.cppblog.com/ming81/archive/2011/01/19/138867.html
			
			// (ok) (搬运工)Mangos源码分析（5）：服务器结构探讨之最终的结构
				http://www.cppblog.com/ming81/archive/2011/01/19/138868.html

			// (ok) (搬运工)Mangos源码分析（6）：登录服的设计之功能需求
				http://www.cppblog.com/ming81/archive/2011/01/19/138872.html

				如果我们总是用一种固定的算法来对密码做散列，那外挂只需要记住这个散列后的字串就行了，用这个做密码就可以成功登录。
				嗯，这个问题好解决，我们不要用固定的算法进行散列就是了。
				这其中之一是一个叫做SRP的算法，全称叫做Secure Remote Password，即安全远程密码。wow使用的是第6版，也就是SRP6算法。

			// (ok) (搬运工)Mangos源码分析（7）：服务器公共组件实现之游戏主循环
				http://www.cppblog.com/ming81/archive/2011/01/19/138874.html

			//  (搬运工)Mangos源码分析（8）：服务器公共组件实现之消息队列
				http://www.cppblog.com/ming81/archive/2011/01/19/138877.html

			//  (搬运工)Mangos源码分析（9）：服务器公共组件实现之环形缓冲区
				http://www.cppblog.com/ming81/archive/2011/01/19/138891.html

			//  (搬运工)Mangos源码分析（10）：服务器公共组件实现之发包的方式
				http://www.cppblog.com/ming81/archive/2011/01/19/138892.html

			//  (搬运工)Mangos源码分析（11）：服务器公共组件实现之状态机
				http://www.cppblog.com/ming81/archive/2011/01/19/138893.html

			//  (搬运工)Mangos源码分析（12）：服务器公共组件实现之事件与信号
				http://www.cppblog.com/ming81/archive/2011/01/19/138907.html

			//  (搬运工)Mangos源码分析（13）：再谈登录服的实现
				http://www.cppblog.com/ming81/archive/2011/01/19/138908.html



			// (搬运工)Mangos服务器的游戏对象和AI系统(一)
				http://www.cppblog.com/ming81/archive/2012/08/28/188524.html

				http://www.cppblog.com/ming81/category/15288.html


			// mangos 配置
				http://www.cppblog.com/ming81/archive/2016/12/16/214497.html

		// SOAP (Simple Object Access Protocol)

	////////////////////////////////////////////////////////////////
	// mangos 结构说明

		// ACE_Wrappers
			依赖的ACE，网络，线程，时间等相关的

		// Detour
			Navimesh相关的

		// framework
			平台相关的一些定义以及一些公用的模板和工具

		// g3dlite
			3d数学库.威廉姆斯学院(williams college)计算机科学系的 Morgan McGuire 写的。助理教授，NVIDIA的研究员。

		// game (lib)
			游戏主要逻辑实现都在这里

		// genrevision
			

		// mangosd (exe)
			主loader,启动各个线程，跟我们的GFLoader类型
		
		// realmd
			登录服务器

		// shared
			
		// zlib
			

	////////////////////////////////////////////////////////////////
	// 依赖的一些第三方介绍

		// g3dlite
			

	
	////////////////////////////////////////////////////////////////
	// 游戏关键类介绍

		////////////////////////////////////////////////////////////////
		// 线程模型
			// io线程
				1*监听线程 (ReactorRunnable)
				n*io线程 (ReactorRunnable)
					ReactorRunnable 数组
					index 0 监听线程
					index > 0 io线程
			// 逻辑线程
				1*主逻辑线程 (WorldRunnable)
			


		////////////////////////////////////////////////////////////////
		// 关键类的注释和说明

			////////////////////////////////////////////////////////////////
			// 网络部分
				// 说明
					WorldSocketMgr + ReactorRunnable + WorldSocket
					等价于我们的
					GFRemoteReactorMng + GFRemoteReactor + GFRemoteConnector

				////////////////////////////////////////////////////////////////
				// WorldSocketMgr.h WorldSocketMgr.cpp 

					// ReactorRunnable
						监听和io线程

					// WorldSocketMgr
						网络连接管理

						// WorldSocketMgr::StartReactiveIO
							开启io线程 index 0 监听线程 index>0 io线程

				////////////////////////////////////////////////////////////////
				// WorldSocket.h WorldSocket.cpp

					// WorldSocket
						客户端的连接处理

						// 关键成员
							WorldSession* m_Session;					// 连接对应的会话对象
							



			////////////////////////////////////////////////////////////////
			// 游戏逻辑部分

				// WorldSession
					玩家在逻辑线程的会话，处理网络io丢过来的消息体

					// 关键成员
						
						Player* _player;								// 会话对象对应的玩家对象
						WorldSocket* m_Socket;							// 会话对象对应的io线程对象
						

				// Opcodes.h 
					客户端服务端交互的msg type头枚举 (enum Opcodes)
					// 客户端上传消息
						CMSG_XXX
					// 服务端下发消息
						SMSG_XXX
					// 服务端和客户端都可以发送的消息 (这个不确定)
						MSG_XXX
					// 注册 opcode 和 handler
						void InitializeOpcodes()
						OpcodeHandler opcodeTable[MAX_OPCODE_TABLE_SIZE];

					// OpcodeHandler
						char const* name;								// 处理名
						SessionStatus status;							// 本处理需要session处于指定状态才处理

				// ObjectGuid.h 
					可以参考下id生成规则

				// World
					游戏世界类，所有运行的驱动源

				////////////////////////////////////////////////////////////////
				// 对象的分类以及继承关系
					// 继承关系
						// class Object
							// class Item
								// (final) class Bag

							// class WorldObject
								// (final) class Corpse
									
								// (final) class DynamicObject
									
								// class GameObject
									// (final) class Transport
										
								// class Unit
									// class Creature
										// (final) class Pet
											
										
									// (final) class Player
										

					// 对象分类
						
			
		////////////////////////////////////////////////////////////////
		// 数据同步机制

			// 玩家登陆同步
			// 属性变化同步
			// 容器变化同步

			// 范围广播
				Player.Say()


		////////////////////////////////////////////////////////////////
		// 数据存储


		////////////////////////////////////////////////////////////////
		// 流程分析
			// 规则
				

			////////////////////////////////////////////////////////////////
			// 网络消息处理流程
				// a: io线程 接受消息，递给逻辑线程
					svc()
					m_Reactor->run_reactor_event_loop
					WorldSocket::handle_input
					WorldSocket::handle_input_missing_data
					WorldSocket::handle_input_payload
					WorldSocket::ProcessIncoming					// 每个验证完的连接都会有其绑定的 WorldSession
					WorldSession::QueuePacket

				// b: 主逻辑线程 处理消息 
					World::Update
					World::UpdateSessions
					WorldSession::Update							// 客户端具体消息处理和派发

			////////////////////////////////////////////////////////////////
			// 新连接的处理流程
				// a: io线程(监听) 接受新连接，丢给io线程
					svc()
					m_Reactor->run_reactor_event_loop
					ACE_Acceptor 创建 WorldSocket 调用 WorldSocket::open
						WorldSocketMgr::OnSocketOpen 把WorldSocket分配给连接最少的ReactorRunnable
						WorldSocket::SendPacket 给客户端发送 MSG_WOW_CONNECTION 消息
						注册io读写事件

				// b: io线程(io) 处理验证信息
					// b.1 给客户端发送验证消息
						svc()
						m_Reactor->run_reactor_event_loop
						WorldSocket::handle_input
						WorldSocket::handle_input_missing_data
						WorldSocket::handle_input_payload
						WorldSocket::ProcessIncoming				// 注: 这边没有加密验证
						WorldSocket::HandleWowConnection			// 处理 MSG_WOW_CONNECTION 消息
						WorldSocket::SendAuthChallenge				// 发送 SMSG_AUTH_CHALLENGE 附带随机种子

					// b.2 处理客户端验证消息
						svc()
						m_Reactor->run_reactor_event_loop
						WorldSocket::handle_input
						WorldSocket::handle_input_missing_data
						WorldSocket::handle_input_payload
						WorldSocket::ProcessIncoming									// 注: 这边没有加密验证
						WorldSocket::HandleAuthSession									// 处理 CMSG_AUTH_SESSION 注意这边有同步的数据库访问
							完成一系列验证信息
							设置验证完成
							创建 WorldSession ,跟当前 WorldSocket 绑定					// m_Session
							给 WorldSession 加载一些账号及附加信息(从数据库加载)		// 
							World::AddSession											// 把 WorldSession 添加给World(也就是丢给逻辑线程)

				// c: 逻辑线程 给客户端回复认证，发送一些辅助信息
					WorldRunnable::run
					World::Update
					World::UpdateSessions
					World::AddSession_													// 同时会处理同号，排队，限号等操作
						WorldSession::SendAuthResponse									// 发送 SMSG_AUTH_RESPONSE 消息
						WorldSession::SendAddonsInfo									// 发送 SMSG_ADDON_INFO 消息
						发送 SMSG_CLIENTCACHE_VERSION 消息
						WorldSession::SendTutorialsData									// 发送 SMSG_TUTORIAL_FLAGS 消息
					
	
			////////////////////////////////////////////////////////////////
			// 获取角色列表 

				// 注1: 到这步时，已经处理过上面的连接处理流程
				// 注2: 这边的异步过程封装的挺好，可以学习下

				// a: 逻辑线程 接受客户端消息 CMSG_CHAR_ENUM 请求角色列表
					WorldSession::Update
					WorldSession::ExecuteOpcode
					WorldSession::HandleCharEnumOpcode										// 异步获取指定账户的角色，
						CharacterDatabase.AsyncPQuery
					Database::AsyncQuery
						m_threadBody->Delay
					SqlDelayThread::Delay													// 请求入队列

				// b: 数据库线程 访问数据库获取账号对应的角色数据
					SqlDelayThread::run
					SqlDelayThread::ProcessRequests
					SqlQuery::Execute
						m_queue->add														// 结果集入CharacterDatabase的结果集队列
				
				// c: 逻辑线程 处理账号对应的角色数据，并返回客户端
					World::Update
					World::UpdateResultQueue
						CharacterDatabase.ProcessResultQueue()
					Database::ProcessResultQueue
					SqlResultQueue::Update
					中间callback的封装省略掉
					CharacterHandler::HandleCharEnumCallback
					WorldSession::HandleCharEnum											// 发送 SMSG_CHAR_ENUM 消息给客户端


			////////////////////////////////////////////////////////////////
			// 登录指定玩家 (这里涉及到初始玩家的数据同步)
				
				// a: 逻辑线程 接受客户端消息 CMSG_PLAYER_LOGIN 请求角色列表 (省略部分跟上面相同或者类似)
					...
					WorldSession::HandlePlayerLoginOpcode
						holder->Initialize													// 这边初始化角色数据相关的所有sql
					...

				// b: 数据库线程  (省略部分跟上面相同或者类似)
					... 

				// c: 逻辑线程 
					...
					CharacterHandler::HandlePlayerLoginCallback
					WorldSession::HandlePlayerLogin
						// 创建玩家对象
							Player* pCurrChar = new Player(this);
						// 反序列化数据库数据给Player对象
							if (!pCurrChar->LoadFromDB(playerGuid, holder))
						// player对象跟当前会话关联
							SetPlayer(pCurrChar);
						


	////////////////////////////////////////////////////////////////
	// 启动流程
		mangosd		main()
		mangosd		Master::Run()
						Master::_StartDB()			启动数据库线程
						WorldRunnable::run()		游戏主逻辑线程
						
	
	////////////////////////////////////////////////////////////////
	// 疑问
		// (ok) 1: 逻辑线程往io线程投递消息 ，io线程往逻辑线程投递消息，使用什么机制让对方及时处理
			a: io线程 -> 逻辑线程
				靠逻辑线程定时驱动来实现，逻辑线程最小时间间隔50ms
			b: 逻辑线程 -> io线程
				没有直接的通知，主要依赖的reactor可写来驱动的,其次，当读阻塞时来驱动发送，
				估计作者也发现了通知不及时导致的数据阻塞问题.

		// 2: 登录服验证后，再进游戏服的流程
			client -> srp6 -> realmd server 认证和选择 mangos server ，然后就断开
			mangos server 和 realmd server 不进行连接，只是通过数据库交互数据(WorldSocket::HandleAuthSession)。
			
		// 3: 对象层级怎么个组织结构，对象层级怎么对应存储结构
			比如我们分场景，玩家，npc，子容器，子对象，mangos怎么区分的

			// tips
				可以查看下 WorldSession::HandleDestroyItemOpcode 对应的代码，貌似能看出点端倪

		// 4: 看看邮件的实现
			

		// 5: 数据存储时，怎么保证同一角色丢给同一个线程
			
